---
layout: default
number: "13"
title: Class 13 - Playtesting
---

# Class 13 - Playtesting

<div class="emulation" markdown="1">
## Play homework
* [Porklike](https://www.lexaloffle.com/bbs/?tid=37045)
</div>

<div class="img" markdown="1">
<span class="imgRef"><a href="https://www.lexaloffle.com/bbs/?tid=37045"> &#x274B; </a></span>
<img src="{{ site.baseurl }}/assets/img/porklike.gif">
<figcaption>Porklike</figcaption>
</div>

<div class="img2" markdown="1">
<span class="imgRef"><a href="https://aylanonsense.itch.io/just-one-boss"> &#x274B; </a></span>
<img src="{{ site.baseurl }}/assets/img/boss.png">
  <figcaption>Just One Boss by ayla nonsense</figcaption>
</div>

<div class="themes" markdown="1">
## Topics

* Playtesting methodology
* Playtesting workshop
* workshop: procedural generation with roguelikes

</div>

<div class="description" markdown="1">
<div class="summaries" markdown="1"><a target="" href="https://www.lexaloffle.com/bbs/?tid=37045">üê∑ Porklike</a>
</div>

## Description

# Playtesting

The word "playtesting," like the word "game," is overused and can mean different things to different people. In general, the term covers any activity where you are playing a game in progress for the purpose of improving it. But different playtests may have different goals, and it is important to know what your goals are before you do anything.

The concepts in these descriptions of different kinds of playtesting are more important than the labels.

*Bug Testing (or Quality Assurance)*

The purpose of QA is to find errors in the game's behavior relative to its design. "Fun" does not enter the equation. If the designer says that the game should do one thing and it actually does another (even if what the game¬†*is*¬†doing may be superior), that is a bug that needs to be identified.

Normally, we think of bug testing as specific to video games. Board games do have a corresponding kind of testing, where the purpose is to find holes in the rules and dead ends in gameplay -- gaps in the game that the designer did not cover.

*Focus Testing*

In a focus test, you bring together players that are part of the target audience's demographic in order to determine how well a game serves their needs. This is normally done for marketing purposes, but if game designers are involved it can also help to make the game more enjoyable for that particular demographic.

*Usability Testing*

In a usability test, players are given specific tasks to accomplish in an attempt to see whether they understand how to control the game. This is done frequently in the greater software industry to make sure that a piece of software is easy to learn and easy to use. Video games can take advantage of this as well, and results from a usability test can be used to either change the controls or modify the early levels to teach those controls more effectively.

In board games, usability is doubly important, because there is no computer to respond to player input for you. If you misunderstand how houses work in¬†*Monopoly*¬†and place them on Community Chest spaces, the game will not stop you. By observing players who are trying to play your game, you can learn a lot about how to design the various game bits so that they are easy and intuitive to use.

*Balance Testing*

A fun game can quickly become boring if some kind of play exploit exists that lets a player bypass most of the interesting choices in the game. If only one strategy can win and it is just a matter of which player follows that strategy the best, it is not as interesting as if there are multiple paths to victory. Likewise, if one player has a clear advantage over the others, it is important to identify that so that players do not feel the game is being unfair. The purpose of this kind of test is to identify imbalances in the game so that the designer can fix them.

*Fun Testing*

A game can be usable, balanced and functional and still be uninteresting. That elusive "fun factor" may be hard to design intentionally, but when people are playing the game it is pretty obvious whether they are having fun or not. Certain aspects of the game may be more fun than others, so it is also important to figure out what parts of the game need to stay the same... not just what to change.

All of these forms of testing have some elements in common. Best practices are similar if not identical. All are important to the success of a project. So why make a distinction?

The reason is that each is appropriate at different stages of completion in a project. Each kind of testing has different goals, and you need to know what your goal is before you can achieve it.

**Order of Effects**

When should you do which kind of playtesting? What order do you do them in? A lot depends on your particular project, so some of this will be up to your judgment as the designer. However, there are some guidelines.

-   Very early on in the project, you need to make sure your project will meet its design goals (usually the "design goal" is to make a game that's fun to play). Testing for fun is necessary to make sure you do not spend a lot of time building on the wrong foundation. If you are making a game for a specific market, focus testing may be involved at an early stage as well, simply to ask the target audience if a game with a particular concept sounds interesting to them at all.
-   Once you know that you have something, you need to solidify the mechanics. Design the whole game, making sure that all the details are taken care of. Test for "bugs." (Note that bug testing in software projects is often done continually throughout the project, increasing in intensity toward the end. Non-digital games are easier to "debug" though, and a "bug" can stop a playtest in its tracks, so it is important for us to have a complete set of rules early in the process.)
-   Once the game is fun and the design is complete, gradually shift
    from testing for fun to testing for game balance. Make sure that all
    the numeric values and player abilities are where you want them to
    be.
-   When the game is working and balanced, towards the end, you'll want to think more about the usability of the game. When you change usability you are not changing any mechanics, merely the way those mechanics are presented visually to the players. This is an important step that is often neglected. If you've ever encountered a game that you could only learn by being taught by another player (as opposed to reading the rules yourself), that is the kind of usability failure you want to avoid in your own projects. You may also do additional focus testing at this time, to make sure that the theme and visual elements of the game appeal to the target audience.

Remember, these are just guidelines. If it is incredibly important that your game be well received by a particular demographic, for example, you may be doing focus testing throughout the project at all stages. Do not let this order of things be your master.

## Procedural generation

### roguelike

Roguelike (or rogue-like) is a subgenre of role-playing computer games traditionally characterized by a dungeon crawl through procedurally generated levels, turn-based gameplay, grid-based movement, and permanent death of the player character. Most roguelikes are based on a high fantasy narrative, reflecting their influence from tabletop role playing games such as Dungeons & Dragons.

Though Beneath Apple Manor predates it, the 1980 game Rogue, which is an ASCII based game that runs in terminal or terminal emulator, is considered the forerunner and the namesake of the genre, with derivative games mirroring Rogue's character- or sprite-based graphics. These games were popularized among college students and computer programmers of the 1980s and 1990s, leading to hundreds of variants. Some of the better-known variants include Hack, NetHack, Ancient Domains of Mystery, Moria, Angband, Tales of Maj'Eyal, and Dungeon Crawl Stone Soup. The Japanese series of Mystery Dungeon games by Chunsoft, inspired by Rogue, also fall within the concept of roguelike games. 

## Extra tutorials

<iframe width="560" height="315" src="https://www.youtube.com/embed/HnY7Inp74dw?si=aaDrM18Zg5iU8Dxa" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
*Making a Roguelike, by Krystian Majewski*



</div>

<div class="readings" markdown="1">
## Code homework

For homework this week you will need to finish a draft working prototype of your game for our last playtesting in week 14. This includes:

* Working Code
* At minimum the basic "first level" or challenge must be implemented
* Basic sound added
* Win / lose state or other mechanics
* Debugging set up
* A list of questions to ask playtesters after they try out your prototype

### Credits

* Playtesting: the design process by Cathie LeBlanc CC BY SA
* Game Design Concepts by Ian Schreiber 2009 CC BY 3.0
* Roguelike by Wikipedians CC BY SA
* Porklike (c) by  Krystian Majewski,
* Making a Roguelike by Lazy Devs

</div>

